# 8-5. [심화학습] 캐시 매핑 기법

- 페이지 테이블 매핑 방식에는 `직접 매칭`, `연관 매핑`, `집합-연관 매핑`이 있다.
    
    ⇒ 그리고 이는 캐시에서도 비슷하게 사용
    
- 그러나 **캐시의 크기는 메모리보다 작기 때문**에, 항상 메모리의 일부 페이지만 갖고 있다.
    
    ⇒따라서 페이지 테이블의 직접 매핑과 캐시의 직접 매핑은 의미가 다르다.
    
    - 직접 매핑
        - 페이지 테이블: 물리 메모리에 모든 페이지 테이블을 가지고 있다.
        - 캐시: 캐시된 데이터가 매번 같은 자리로 올라오기 때문에 캐시 테이블 전체를 찾아보지 않아도, 캐시 히트나 캐시 미스를 바로 알 수 있다.

## 01 캐시 직접 매핑

캐시도 메모리를 일정 크기로 나눔(메모리 페이징 방식과 동일) ⇒ 일정 크기로 나눈 덩어리 `P`(페이지)

- CPU가 메모리에 접근할 때 사용하는 주소를 `<P,D>`로 표현하는데 여기서 `P`는 페이지 번호, `D`는 페이지 내에서 거리를 의미한다. (페이징 기법과 동일)

메모리는 N개의 페이지로, 캐시는 M개의 페이지로 구성된다고 가정할 때, 

- 캐시는 메모리 보다 작기 때문에 N >> M
- 블록: 직접 매핑에서 메모리 페이지 수 N을 캐시의 페이지 수 M으로 나눈 것
    - 즉, 메모리의 페이지 수 N = M x 블록 수
- 메모리의 블록이 캐시로 올라올 때, 항상 같은 위치에 올라온다.
    - ex. 블록의 첫번째 페이지는 항상 캐시의 첫번째 페이지로, 블록의 두번째 페이지는 항상 캐시의 두번째 페이지로만 올라온다 .

직접 매핑에서는 캐시에 블록의 일정 위치 데이터가 올라오기 때문에, 메모리의 어떤 블록에서 올라온 페이지인지만 확인하면 된다. 

⇒ 따라서 캐시에 블록 번호를 명시하는데, 이를 태그(tag)라고 한다.

⇒ 직접 매핑에서는 캐시 히트나 캐시 미스가 있는지 알기 위해 태그 확인

- CPU가 메모리에 접근하려는 주소 `<P,D>`는 `<tag, bd, D>`로 바꿀 수 있고, 원하는 데이터를 캐시에 얻기 위해 `<tag, D>`를 사용한다. (여기서 `bd`는 블록에서의 거리(block distance))

![image](https://user-images.githubusercontent.com/74661937/196139415-592118d5-c67c-48f0-893f-6d43ff332340.png)

직접 매핑 방식의 가장 큰 특징은 **메인 메모리의 페이지가 캐시의 정해진 위치에만 들어갈 수 있다**는 점. 

메모리의 주소 4bit 중에 끝에 2bit(block distance, bd)에 주목 

⇒ 메모리 상에서 같은 `bd` 를 가진 데이터는 **캐시의 동일한 위치**에 올라간다. 

(ex. 캐시의 01 위치할 수 있는 데이터 - 메모리의 각 블록의 01에 위치한 tiger, dove, shark, cobra)

⇒ 그리고 이 중 **어떤 블록에 있는 데이터**가 올라왔는지 확인하기 위해 `태그`를 유지한다. 

bd(block distance)가 01, 인데 tag가 11인 데이터가 올라갔다 ⇒ corbra

**직접 매핑의 장점**

- 메모리의 페이지가 캐시의 같은 위치에 올라오기 때문에
    
    ⇒ **태그만 확인**하면 **캐시히트나 캐시 미스를 빠르게 확인**할 수 있다. 
    

**단점**

- 그러나, 페이지가 같은 위치에만 올라오기 때문에
    
    ⇒ 자리 다툼이 발생한다는 단점
    
    ⇒ 그리고 **이를 완화한 것이 `연관 매핑`**
    

## 02 캐시 연관 매핑

- 캐시 연관 매핑은 페이지 연관 매핑과 동일
- 메모리 워드가 **캐시의 어느 위치에도 자유롭게 올라갈 수 있으**므로,
    - 캐시가 메모리 워드의 주소를 전부 다 가지고 있다.
    - CPU가 특정 주소를 필요로 할 때, 캐시에서 검색하여 찾는 경우는 캐시 히트
    - 그러나, 찾지 못하면 캐시미스가 발생하여 메모리에서 원하는 데이터를 가져온다.
- **장점**
    - 캐시 메모리를 자유롭게 사용할 수 있다는 것이 장점
- **단점**
    - 캐시 히트인지, 캐시 미스인지 확인을 위해 **캐시의 모든 주소를 검색해야한다**는 단점
    - 이러한 이유로, 연관 매핑은 직접 매핑보다 **느리다** .

![image](https://user-images.githubusercontent.com/74661937/196139536-906efa5c-3a4e-49ce-9c9e-2ec561abd6b1.png)


## 03 캐시 집합-연관 매핑

- 직접 매핑과 연관 매핑의 장점만 취한 방식
- 집합-연관 매핑은 캐시를 K개의 집합으로 나누고, 각 집합에 직접 매핑을 사용
    - 직접 매핑의 단점: 끝이 00 (bd 00)으로 끝나는 페이지는 캐시에 하나밖에 없기 때문에 자리다툼이 일어난다.
- 집합-연관 매핑은 직접 매핑을 하는 캐시 메모리를 K개로 나눔으로써, 같은 끝자리를 가진 캐시 메모리도 K개가 된다.
    - **따라서, 직접 매핑의 자리다툼 문제가 완화!**
- 또한 집합 내에서 **직접 매핑을 사용**하기 때문에, 연관 매핑처럼 모든 캐시를 뒤지는 일이 없이 **바로 캐시 히트 여부를 알 수 있다.**

![image](https://user-images.githubusercontent.com/74661937/196139703-58c19c97-9a7b-4184-a6eb-6525e9711268.png)

- K= 2 (2개의 캐시 집합)
- 하나의 집합에 2개의 페이지 사용
    
    ⇒ 주소 P의 4bit 중 마지막 1bit만 bd를 나타내고, 앞의 3bit가 태그
    

**즉, 주소의 끝이 0인 페이지는 2개의 집합 중 비어있는 첫번째 위치에 들어가고,** 

**끝이 1인 페이지는 2개의 집합 중 비어있는 마지막 위치에 들어간다.**