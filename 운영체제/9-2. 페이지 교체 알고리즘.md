# 9. 가상 메모리 관리
## 9.2. 페이지 교체 알고리즘
- 메모리가 꽉 찼을 때 어떤 페이지를 스왑 영역으로 보낼지 결정하는 `재배치 정책`
### 9.2.1. 페이지 교체 알고리즘의 개요
- 프로세스가 요구한 페이지가 현재 메모리에 없으면 `페이지 부재` 발생
    - 페이지 부재시에 스왑 영역에서 페이지를 메모리로 가져오는데, **이 때 메모리가 꽉 찼다면 메모리에 있는 페이지를 스왑 영역으로 내보내야** 한다. 
    - 페이지 교체 알고리즘은 스왑 영역으로 내보낼 페이지를 결정하는 알고리즘. 
    - 메모리에서 사용할 가능성이 적은 페이지를 대상 페이지로 선정해 페이지 부재를 줄이고 시스템 성능을 향상시키는 것이 목표이다.
    
#### 페이지 교체 알고리즘의 성능 평가 기준
- 페이지 교체 알고리즘은 성능 뿐만 아니라 유지 비용도 고려해야.
- 같은 메모리 접근 패턴을 사용하여 페이지 부재 횟수와 페이지 성공 횟수를 비교

### 9.2.2. 무작위 페이지 교체 알고리즘
- 페이지 교체 알고리즘 중 가장 간단하게 구현할 수 있는 방식
- 스왑 영역으로 쫓아낼 대상 페이지를 특별한 로직 없이 무작위 선정
- 대부분 프로세스 메모리 접근 패턴을 확인하면, 메모리의 인접한 영역에 저장되는 지역성을 가지는데, 무작위 페이지 교체 알고리즘은 이러한 지역성을 전혀 고려하지 않는다. 
- 따라서 자주 사용하는 페이지가 스왑영역으로 쫓아낼 대상 페이지로 선정되기도.
- 이렇듯 알고리즘의 성능이 좋지 않기 때문에 사용되지 않는다. 


### 9.2.3. FIFO 페이지 교체 알고리즘
- 선입선출 페이지 교체 알고리즘
- 시간상으로 메모리에 가장 먼저 들어온 페이지를 대상 페이지로 선정해 스왑영역으로 쫓아낸다. 
- FIFO 페이지 교체 알고리즘은 `큐`로 구현
- 메모리의 맨 위에 있는 페이지는 가장 오래된 페이지이고, 새로운 페이지는 항상 맨 아래 삽입된다. 
    - 메모리가 꽉 차면 맨 위에 페이지가 스왑영역으로 가고 나머지 페이지들이 위쪽으로 이동
    - 새로운 페이지가 아래쪽 남은 공간에 들어온다. 
- 페이지 교체 알고리즘에서는 앞으로 사용하지 않을 페이지를 스왑 영역으로 옮기는 것이 중요하다.
    - FIFO 페이지 교체 알고리즘은 `시간의 지역성`을 고려해 가장 오래된 페이지를 대상 페이지로 선정하는데,
        - 문제는 메모리에 올라온지 오래 되었더라도 자주 사용되는 페이지가 있는데 FIFO 페이지 교체 알고리즘에서는 메모리에 언제 올라왔는지만 신경쓰므로, 자주 사용되는 페이지더라도 스왑 영역으로 옮겨버리기도 한다.
    - 이러한 문제를 보완한 것이 `2차 페이지 교체 알고리즘`이다.


### 9.2.4. 최적 페이지 교체 알고리즘
- 앞으로 사용하지 않을 페이지를 스왑 영역으로 옮긴다. 
- 메모리가 앞으로 사용할 페이지를 미리 살펴보고, 페이지 교체 선정 시점부터 사용 시점가지 가장 멀리 있는 페이지를 대상 페이지로 선정한다.
- 미래의 메모리 접근 패턴으로 보고 대상 페이지를 결정하기 때문에 성능이 좋다. 하지만! 미래의 접근 패턴을 안다는 것이 불가능하여 실제로 구현할 수 없다.
- 따라서, 구현이 가능하면서도 성능이 최적 페이지 교체 알고리즘에 근접하는 방법을 연구한 결과, 최근 최소 사용 알고리즘인 `Least Recently Used(LRU)`, 최소 빈도 사용 알고리즘인 `Least Frequently Used(LFU)`, 최근 미사용 알고리즘인 `Not Used Recently(NUR)` 등이 개발되었다.
    - 이러한 알고리즘은 과거의 데이터를 바탕으로 미래의 접근 패턴을 추정하기 때문에 `최적 근접 알고리즘` 이라고 부른다.

- **최적 근접 알고리즘**
    - 최적 페이지 교체 알고리즘은 미래의 데이터를 참고하기 때문에 예측이 불가능하지만, 
    - 최적 근접 알고리즘은 **과거의 데이터로부터 미래를 예측하기 때문**에 구현 가능하며 최적 페이지 교체 알고리즘과 유사한 성능을 보인다.
    - `LRU 페이지 교체 알고리즘`
        - 페이지에 **접근한 시간을 기준**으로 대상 페이지를 선정
        - 페이지에 접근한 시간과 현재의 시간차가 가장 큰 페이지를 스왑 영역으로 옮긴다.
    - `LFU 페이지 교체 알고리즘`
        - 페이지가 **사용된 횟수를 기준**으로 대상 페이지 선정
        - 가장 적게 사용된 페이지를 스왑 영역으로 옮긴다.
    
### 9.2.5. LRU 페이지 교체 알고리즘
- 최근 최소 사용 페이지 교체 알고리즘
- 메모리에 올라온 후 가장 오랫동안 사용되지 ㅇ낳은 페이지를 스왑 영역으로 옮긴다.(=오래 전에 사용된 페이지를 대상 페이지로 선정)
- 기준: 시간, 카운터, 참조 비트

#### 9.2.5.1. 페이지 접근 시간에 기반한 구현
- 페이지에 접근한 시간을 기록하여 구현하는 방식
    - cf. FIFO 페이지 교체 알고리즘: 메모리에 올라온 시간을 기준으로 가장 오래된 페이지 교체
- LRU 페이지 교체 알고리즘은 페이지에 접근한지 가장 오래된 페이지를 교체한다.(=페이지에 읽기, 쓰기, 실행과 같은 연산이 이루어진 시간을 기준으로)
- 숫자가 가장 작은 페이지 즉, 사용된지 가장 오래된 페이지를 대상 페이지로 선정
- 메모리 접근 패턴을 변경하면 LRU 페이지 교체 알고리즘의 성능이 FIFO 페이지 교체 알고리즘만큼 느려지기도 하고, 최적 페이지 교체 알고리즘만큼 좋아지기도 한다.
- FIFO 페이지 교체 알고리즘보다 우수하고 최적 페이지 교체 알고리즘보다 조금 떨어진다.

#### 9.2.5.2. 카운터에 기반한 구현
- 접근 시간 대신 카운터를 사용해 구현하는 방식
- 그러나 접근 시간을 기록하든, 카운트를 하든 두 방법 모두 추가적인 메모리 공간을 필요로 한다는 단점 존재
- e.g. 0~1024초를 표시하려면 10bit 가 필요하고, 더 큰 숫자를 표시하려면 더 많은 비트를 사용해야한다.
    - 이러한 추가 공간으로 인해 사용자가 사요할 수 있는 공간이 낭비된다.

#### 9.2.5.3. 참조 비트 시프트 방식
- LRU 페이지 교체 알고리즘을 실제 구현하는데 참조 비트 시프트 방식을 사용할 수 도 있다.
- 참조 비트 시프트 방식은 각 페이지에 일정 크기의 참조 비트를 만들어 사용하는 것
- 참조 비트의 초깃값은 0이며, 페이지에 접근할 때마다 1로 바뀐다. 
- 참조 비트는 주기적으로 오른쪽으로 한칸씩 이동(shit)
- LFU 페이지 교체 알고리즘과 혼동되기도 하는데, `LFU 페이지 알고리즘`은 페이지의 접근 횟수를 측정하여 대상 페이지를 선정하지만, `LRU 참조 비트 시프트 방식`은 참조한 시간을 기준으로 대상 페이지를 선정한다.
- 단점: 비록 1bit라도 참조 비트 시프트 방식도 작지 않은 공간을 사용하기 때문에 공간을 낭비하는 단점이 있다.
    - cf. `LRU 페이지 교체` 알고리즘의 단점은 접근 시간이나 참조 비트를 유지하기 위한 메모리가 추가로 필요하기 때문에 낭비되는 메모리 공간이 많다는 것. 

### 9.2.6. LFU 페이지 교체 알고리즘
- 최최소 빈도 사용 알고리즘 이라고도 한다.
- 페이지가 몇번 사용되었는지를 기준으로 대상 페이지를 선정
- 현재 프레임에 있는 페이지마다 그동안 사용된 횟수를 세어 횟수가 가장 적은 페이지를 스왑 영역으로 옮긴다.
- 처음 메모리에 올라온 페이지의 사용 빈도가 1, 페이지가 사용될 때마다 하나씩 증가.
- 일반적으로, LRU 페이지 교체 알고리즘과 성능이 비슷하다고 알려있다.
    - LRU, LFU 페이지 교체 알고리즘 모두 FIFO 페이지 교체 알고리즘보다 성능이 우수하다.
- 단점: LFU 페이지 교체 알고리즘의 단점은 LRU 페이지 교체 알고리즘과 마찬가지로 낭비되는 메모리 공간이 많다는 것.페이지 접근 횟수(빈도)를 표시하는 데 추가 공간이 필요하므로 그만큼 메모리 낭비 발생

### 9.2.7. NUR 페이지 교체 알고리즘
- Not Used Recently page replacement algorithm 
- LRU, LFU 페이지 교체 알고리즘과 성능이 거의 비슷하지만, 불필요한 공간 낭비 문제를 해결한 알고리즘. 
- 최근 미사용 페이지 교체 알고리즘
- 알고리즘에서 접근 시간이든 접근 빈도든 정확한 값을 유지하는 것은 공간만 많이 차지할 뿐 의미가 없다. 
    - NUR 페이지 교체 알고리즘은 이러한 경향을 반영한 방식으로, 추가 비트 2개만 사용해서 미래를 추정한다.
- NUR 페이지 교체 알고리즘에서는 페이지마다 참조 비트와 변경 비트를 갖기 때문에 추가되는 메모리 공간이 2 비트 뿐이다.
    - 참조 비트와 변경 비트는 모두 초깃값이 0 => (0, 0)
    - 참조 비트: PTE의 접근 비트 / 페이지에 접근(read/excute)하면 1
        - 페이지에 `읽기 또는 실행 같은 접근`이 발생하는 경우 (1, 0)
    - 변경 비트: PTE의 변경 비트 / 페이지가 변경(write/append)되면 1 
        - 페이지에 `쓰기 또는 추가 같은 변경`이 일어나면 (0, 1)
- 대상 페이지를 선정할 때, (0,0) => (0,1) => (1,0) => (1,1) 중에 하나를 고르는데, 가장 먼저 (0,0)인 페이지를 선정한다.
    - 즉, 접근한 적도 변경한 적도 없는 페이지를 스왑영역으로 옮긴다.
    - 참조 비트를 우선적으로 고려한다. 참조비트가 0인 페이지를 먼저 찾고, 없으면 변경 비트가 0인 페이지를 찾는다.
    - 모든 페이지의 비트가 (1,1)인 경우 어떤 페이지가 더 자주 사용되는지 알 수 없기 때문에 NUR 페이지 교체 알고리즘을 정상적으로 적용할 수 없으므로 모든 페이지가 (1,1)이 되었을 경우엔 모든 페이지 비트를 (0,0)으로 초기화 한다.(reset)
- 최적 근접 알고리즘인 LRU, LFU, NUR 페이지 교체 알고리즘의 성능은 거의 비슷하며 FIFO 페이지 교체 알고리즘보다 우수하다. 
    - NUR은 참조 비트와 변경 비트(2 bit)만 추가하여 다른 알고리즘과 유사한 성능을 낼 뿐만 아니라 쉽게 구현할 수 있기에 가장 많이 사용되고 있다.
    

### 9.2.8. FIFO 변형 알고리즘
- FIFO 페이지 교체 알고리즘은 메모리에 올라온 순서만 고려하고, 자주 사용하는 페이지를 고려하지 않아서 성능이 좋지 않았다.
- 이를 개선한 FIFO 변형 알고리즘이 `2차 기회 페이지 교체 알고리즘`과 `시계 알고리즘`

#### 9.2.8.1 2차 기회 페이지 교체 알고리즘
- 2차 기회 페이지 교체 알고리즘은 FIFO 페이지 교체 알고리즘과 마찬가지로 **큐를 사용**하지만, 
- 차이점은 특정 페이지에 접근하여 페이지 부재 없이 성공할 경우 해당 페이지를 큐의 맨 뒤로 이동하여 대상 페이지에서 제외시킨다.
    - 즉, 성공한 페이지를 큐의 맨 뒤로 옮김으로써 기회를 한 번 더 주는 것.
    - 이로 인해 대상 페이지로 선정될 활률이 줄어든다.
- 성능은 LRU, LFU, NUR 페이지 교체 알고리즘보다 약간 낮고, FIFO 페이지 교체 알고리즘보다 약간 높은 것으로 알려져 있다.
- 그러나 큐를 유지하는 비용이 높고, 페이지가 성공하면 큐의 중간에 있는 값을 뒤로 이동하는 작업이 추가되는 것이 단점

#### 9.2.8.2. 시계 알고리즘
- 2차 기회 페이지 교체 알고리즘과 유사하지만, 실제 구현은 서로 다르다.
- 차이점: 2차 기회 페이지 교체 알고리즘은 큐를 사용하지만, 시계 알고리즘은 원형 큐를 사용한다.
    - `원형큐`: 시계 알고리즘에서는 스왑 영영ㄱ으로 옮길 대상 페이지를 가리키는 포인터를 사용하는데, 이 포인터가 큐의 맨 바닥으로 내려가면 다음번엔 다시 큐의 처음을 가리킨다.
    - 포인터가 가리키는 페이지가 스왑 영역으로 좇겨나면 대상 포인터를 밑으로 이동시킨다.
        - 이 때, 참조 비트가 1인 페이지는 건너뛰고, 메모리의 바닥에 도착하면 다시 메모리의 상단으로 이동
            - 참조 비트가 1인 페이지를 대상 페이지에서 제외하는 이유는 2차 기회 페이지 교체 알고리즘처럼 기회를 한 번 더 주기 위해서. 
            - 그러나 이렇게 대상에서 제외되는 경우는 단 한 번뿐이고, 참조 비트가 1인페이지를 건너뛸 때는 이를 0으로 바꿔놓는다.(즉, 다시 한 바퀴 돌아서 대상포인터가 오면 제외하지 않겠다는 의미)
- 시계 알고리즘은 대상 포인터가 각 페이지당 참조 비트 하나만 추가하면 도기 때문에 NUR 페이지 교체 알고리즘보다 추가 공간이 적게 들지만, 
- 알고리즘이 복잡하고 계산량이 많다는 것이 단점.


### 페이지 교체 알고리즘 종류 정리
